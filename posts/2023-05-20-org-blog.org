#+title: Blog Homesteading with Clojure and Org-Mode
#+subtitle: Building a custom static site generator for just me
#+date:<2023-04-22 Sat>
#+options: H:6

* Blog Homesteading with Clojure and Org-Mode
:LOGBOOK:
CLOCK: [2023-05-25 Thu 11:25]
CLOCK: [2023-05-24 Wed 21:45]--[2023-05-24 Wed 22:10] =>  0:25
CLOCK: [2023-05-21 Sun 13:55]--[2023-05-21 Sun 14:59] =>  1:04
CLOCK: [2023-05-21 Sun 13:21]--[2023-05-21 Sun 13:54] =>  0:33
CLOCK: [2023-05-20 Sat 10:45]--[2023-05-20 Sat 11:51] =>  1:06
:END:

** What is Blog Homesteading?
:PROPERTIES:
:CUSTOM_ID: intro
:END:
Jack Rusher [[https://jackrusher.com/journal/homesteading.html][has a post about digital homesteading]]. The post touches on crafting your own online presence and not relying solely on social media. I've heard similar advice on the internet. I think it's good advice to keep your content in a medium and place you control and /syndicate/ it out to social media.

I want to generate content, host it on my own website, and syndicate it out to social media. If I were smart, and valued my time, I would use a ready made static site generator. There are many available. However, I'm /not/ smart, and I /don't/ value my time. I also have specific requirements that are too niche to satisfy with any generic static site generator!

There is a quote from the homesteading post that helps me validate building a totally custom, from scratch, static site generator.

  #+begin_quote
  The early blogging scene was exclusive in the way new things often are. We felled our own timber, configured our own servers, wrote our own software, and carved our webpages out of wood using Stone Age tools — none of it was particularly easy or convenient. ... my handmade personal site was like a cabin in the woods
  #+end_quote

This blog post is about creating a personal website and blog platform that let's me write posts and content in Org Mode and generate a static site using some Cojure in a quick and /easy/ way. It's not a generalized platform, it's just a collection of functions that let me publish a static site. The Github repo [[https://Github.com/jgoodhcg/org-blog][is here]]. I host it using [[https://www.digitalocean.com/community/tutorials/how-to-deploy-a-static-website-to-the-cloud-with-digitalocean-app-platform][digital ocean app platform]].

** Specific Requirements
:PROPERTIES:
:CUSTOM_ID: specifics
:END:
Here is a list of requirements for this project that I haven't found holistically in any other platform.

*** Org-Mode Compatibility
I like to write in org mode. It feels like the best medium for creating written content. It's convenient for me because I use Doom Emacs as my primary text editor. I could probably save a bunch of time and effort by just being comfortable writing in markdown but ... /I just don't want to do that/.
*** Ease of Styling
I want to use Clojure hiccup and tailwind for making HTML. I don't want to learn a template language or the conventions of an arbitrary theme plugin system.
*** Efficient Load Times
I want a static site with minimal dependencies.
*** Flexibility
If I want to do something interesting like add comments, or make an interactive experience on my site I don't want to have to /swim against the current/ with a platform's conventions to do it.
*** Minimal Overhead
I want to be as close to basic HTML, CSS, and javascript as possible while still writing and creating in Clojure, hiccup, tailwind, and org mode. Deploying and writing should also be easy. Low friction to producing will help me actually write more.
*** Cost-Effective
Cheap is good, so free or low cost hosting with no scaling concerns would be best.

** Previous Blogging Solutions
  :PROPERTIES:
  :CUSTOM_ID: journey
  :END:

Some of the things I've tried recently have been interesting but didn't satisfy enough of my requirements.

*** Cryogen
   :PROPERTIES:
   :CUSTOM_ID: cryogen
   :END:

Cryogen is a static site generator written in Clojure, and it worked well for what it offered. However, my main challenge with Cryogen was writing in markdown. I want to write in Org-Mode. I tried to write in Org-Mode and convert to markdown but it was a tedious process. I also found deployment tedious. I had a repo for the static site generator and a different repo for the static site it generated. There are probably easier ways to do it but I found the process I had, and the idea of figuring out a better process, too daunting.

*** Ghost
   :PROPERTIES:
   :CUSTOM_ID: ghost
   :END:

Ghost is a popular platform that offers beautiful out-of-the-box themes. I appreciated how it took care of certain conveniences like meta data for Twitter previews and Google result displays. However, my experiences using the editor weren't as pleasant as I would have liked, and I was reluctant to learn yet another theme syntax to customize styles. Also on a cold request the load times were pretty bad.

*** Other Considerations
   :PROPERTIES:
   :CUSTOM_ID: considerations
   :END:

A few other platforms caught my attention as well:

- *Roam Research* as the blog site: While the idea of using Roam Research was interesting, the fact that it would create a Single Page Application (SPA) and not a static site raised concerns about load times. Additionally, setting up a custom domain appeared to be either difficult or potentially costly.

- *org-static-blog*: As the name implies, org-static-blog does exactly what it promises – it's a simple static blog generator for Emacs' Org-Mode. However, styling it proved to be an arduous task, as all the template HTML is embedded within a string in an Emacs configuration file.

** Project Overview
  :PROPERTIES:
  :CUSTOM_ID: setup
  :END:
I decided to start from scratch. From an empty git repo I added a directory with some org mode blog posts and a jvm clojure file. I went from there building with the REPL. What I ended up with looked like this:

  #+begin_example
├── css
├── pages
├── posts
├── src
│   └── org_blog
│       ├── common
│       └── pages
└── static
    ├── archive
    ├── css
    │   └── svg
    ├── img
    ├── posts
    │   ├── 2023-04-22-kitchen-sink
    │   └── 2023-05-20-org-blog
    └── resume
  #+end_example

*** css
  Contains one ~input.css~ file with some tailwind `@apply` statements for things that I can't style directly in the template src files.

*** pages
Contains one off org files for pages that are not blog posts. As of now, that is just my resume.

*** posts
All of the org files representing my blog posts.

*** src
This is where all of the clojure code exists to build the site. It's starts with ~core.clj~. I've organically organized it loosely into different namespaces. Right now the only directories needed are ~common/~ and ~pages/~.

*** static
This is the directory with the static assets. All of the html, css, and images are here. I commit images right to the repository. Videos I will host in an s3 bucket and link out. When the Github repo updates the digital ocean app pulls in the changes and serves everything in this directory.

** Workflow
  :PROPERTIES:
  :CUSTOM_ID: workflow
  :END:

  I'm really happy with my workflow. It starts with opening Doom Emacs. If I want to just write I open or create an org file in the ~posts/~ directory and start writing. If I want to save my progress I can commit and push my changes to the Github repo.

  If I want to see what a post looks like I can start a repl and eval the ~org-blog.core~ namespace. That starts up a development webserver locally and generates all the static files. It includes a filewatcher so any changes to source code or the org mode blog posts trigger a re-generation of the static files. I can then go to ~localhost:8080~ and see the post I'm working on.

  Not everything I want to make is an Org-Mode based blog post. For one off pages I make a clojure namespace that uses hiccup to generate an html page. All of the reusable components of the site are clojure functions that generate hiccup. Building up a page is functional and almost /React/ like.

  When I'm ready to deploy I just need to commit the changes in ~static/~.

** Code
  :PROPERTIES:
  :CUSTOM_ID: code
  :END:
There are some areas of the codebase that I think are rather interesting.

*** Dev webserver
To be able to develop locally the project needed a dev webserver. That exists in ~org-blog.dev-server~ namespace. It uses ~org.httpkit.server~. The heart of it is just a simple handler function that does a little something different per content type.

#+begin_src clojure
(defn handler [req]
  (let [resource-path (str "static" (:uri req))
        file (io/file resource-path)
        ext  (->> (split resource-path #"\.")
                  last)]
    (if (.exists file)
      (if (.isDirectory file)
        {:status  200
         :headers {"Content-Type" "text/html"}
         :body    (slurp (io/file (str resource-path "/index.html")))}
        {:status  200
         :headers {"Content-Type" (content-type-for resource-path)}
         :body    (if (#{"jpg" "png" "gif"} ext)
                    (io/input-stream file)
                    (slurp file))})
      {:status  404
       :headers {"Content-Type" "text/plain"}
       :body    "Not Found"})))
#+end_src

*** File watcher
What makes developing the site super easy is that it automatically re-generates static files, and reloads the repl, on any file save. In ~org-blog.core~ namespace are a few lines of code that make this possible. This is all built on top of the [[https://github.com/wkf/hawk][hawk library]].

#+begin_src clojure
;; These lines are in `org-blog.dev-server`
(defn watch-source-files [dirs handler]
  (hawk/watch! [{:paths   dirs
                 :handler handler}]))

(defonce source-watchers (atom nil))

;; These lines are in `org-blog.core`
(when (nil? @dev-server/source-watchers)
  (reset! dev-server/source-watchers
          (dev-server/watch-source-files
           ["src" "posts" "pages"]
           (fn [ctx e]
             (when (= (:kind e) :modify)
               (println "File modified:" (:file e))
               ;; Calling `ns-repl/refresh` in another thread (hawk must run this handler in a another thread)
               ;; generates an error
               ;; By wrapping in future, by some magic, the function calls within are scheduled on the main thread I guess
               (future
                 (try
                   (println "Refreshing repl ...")
                   (ns-repl/refresh)
                   (println "Ahhhh, so refreshed!")
                   (regenerate-site)
                   (catch Exception e
                     (when-not (and (instance? IllegalStateException e)
                                    ;; Not sure why this error happens but the repl refreshes when it's thrown so I guess it doesn't matter
                                    (.contains (.getMessage e) "Can't change/establish root binding of: *ns* with set"))
                       (println "Error refreshing repl:" e))))))))))
#+end_src

*** Converting Org-Mode Files with Pandoc

In ~org-blog.common.org~ is the actual conversion of Org-Mode content to html. It relies on [[https://pandoc.org/][pandoc]] and basically shells out to that system dependency. I use some basic templates to isolate the body and the table of contents (toc) and return a vector of the html toc and the html body.

#+begin_src clojure
(defn org->html
  "Requires at least pandoc 3.1.2 installed locally"
  [org-file]

  (let [absolute-org-file  (full-path org-file)
        toc-template-path  (full-path "./src/org_blog/pandoc-template-toc.html")
        body-template-path (full-path "./src/org_blog/pandoc-template-body.html")
        toc-cmd            (str "pandoc -f org -t html "
                                    "--template=" toc-template-path " "
                                    "--table-of-contents " absolute-org-file)
        body-cmd           (str "pandoc -f org -t html "
                                "--template=" body-template-path " "
                                absolute-org-file)
        toc-result         (shell/sh "sh" "-c" toc-cmd)
        body-result        (shell/sh "sh" "-c" body-cmd)]
    (if (and (zero? (:exit toc-result))
             (zero? (:exit body-result)))
      [(:out toc-result)
       (:out body-result)]
      (do (println (str "Error(s):" [(:error toc-result) (:error body-result)]))
          nil))))
#+end_src

** Design Choices
  :PROPERTIES:
  :CUSTOM_ID: design
  :END:
  - Brief about the design inspiration (vaporwave color scheme, LCARS borders)
  - Making it responsive: How to ensure the site works well on all device sizes

** Working with Org-Mode
  :PROPERTIES:
  :CUSTOM_ID: orgmode
  :END:
  - Discuss Org-Mode's benefits for project organization and note-taking
  - Describe how to utilize Org-Mode for blog writing (e.g., headings, links, etc.)
  - Share the workaround for Pandoc's heading interpretation to h6 in Org-Mode

** Handling Images
  :PROPERTIES:
  :CUSTOM_ID: images
  :END:
  - Importance of image management: enhancing blog posts, privacy concerns
  - How to use exiftool to strip GPS data from images
  - Discuss the pros and cons of storing images on Github

** Lessons Learned and Tips for Other Developers
  :PROPERTIES:
  :CUSTOM_ID: lessons
  :END:
  - Share your experiences and any challenges you faced during the project
  - Tips and advice for Clojure developers looking to create their own personal blog sites

** Conclusion
  :PROPERTIES:
  :CUSTOM_ID: conclusion
  :END:
  - Summarize the main points of the blog post
  - Encourage readers to start their own projects and invite them to share their experiences

